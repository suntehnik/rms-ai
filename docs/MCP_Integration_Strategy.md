# Стратегия Интеграции MCP-Агента

Настоящий документ описывает рекомендуемую стратегию интеграции MCP-агента (клиента) с бэкендом для управления требованиями.

## 1. Основной Принцип: Работа от имени пользователя

Ключевой принцип интеграции заключается в том, что агент выполняет все операции от имени конкретного пользователя, который его запустил и аутентифицировал. Это обеспечивает полный аудит действий и гарантирует, что агент не сможет превысить полномочия данного пользователя. Модель с общей "сервисной учетной записью" не используется.

## 2. Метод Интеграции: Прямые вызовы API

Взаимодействие между агентом и бэкендом осуществляется через прямые HTTPS-вызовы к существующему RESTful API. Этот подход обеспечивает синхронную обратную связь и использует уже реализованную и задокументированную бизнес-логику в эндпоинтах API.

## 3. Механизм Аутентификации: Собственный OAuth 2.0 Провайдер

Для безопасной аутентификации пользователя без раскрытия его пароля агенту используется стандарт **OAuth 2.0 Authorization Code Flow with PKCE**.

Ваш собственный Go-бэкенд выступает в роли OAuth-провайдера.

### Процесс аутентификации:

1.  **Инициация входа:** Пользователь запускает в агенте команду `login`.
2.  **Перенаправление в браузер:** Агент открывает веб-браузер и направляет пользователя на страницу входа **вашего бэкенда** (например, `https://your-service.com/login`).
3.  **Вход пользователя:** Пользователь вводит свой логин и пароль на веб-интерфейсе вашего сервиса. **Агент никогда не получает доступ к этим данным.**
4.  **Подтверждение доступа:** После входа бэкенд запрашивает у пользователя разрешение на доступ для "MCP-Агента".
5.  **Передача кода авторизации:** После согласия пользователя бэкенд перенаправляет браузер на локальный URL, который прослушивает агент (например, `http://localhost:8181/callback`), и передает в параметрах временный `authorization_code`.
6.  **Обмен кода на токен:** Агент получает этот код и обменивает его на `access_token` и `refresh_token`, сделав фоновый запрос к эндпоинту `/oauth/token` вашего бэкенда.

## 4. Безопасное Хранение Токенов

Полученные токены необходимо хранить безопасно.

-   **`access_token` (короткоживущий):** Хранится в памяти агента.
-   **`refresh_token` (долгоживущий):** Сохраняется в зашифрованном системном хранилище ОС:
    -   **macOS:** Keychain Access (Связка ключей)
    -   **Windows:** Credential Manager (Диспетчер учетных данных)
    -   **Linux:** Secret Service API / Keyring

Когда `access_token` истекает, агент использует `refresh_token` для получения новой пары токенов без необходимости повторного входа пользователя.

## 5. Необходимые доработки на Бэкенде

Для реализации этой схемы бэкенд должен стать полноценным OAuth 2.0 провайдером.

1.  **Реализовать эндпоинты OAuth 2.0:**
    -   `/oauth/authorize`: Для обработки начального запроса и отображения UI.
    -   `/oauth/token`: Для обмена кодов на токены.
    -   Рекомендуется использовать готовые, проверенные Go-библиотеки (например, `ory/fosite`).
2.  **Регистрация клиентов:** В бэкенде должна быть возможность зарегистрировать MCP-агент как доверенного OAuth-клиента с уникальным `client_id`.

## 6. Отличие от Публичного Реестра MCP

Важно понимать разницу:

-   **Ваш Сервер:** Вы полностью контролируете аутентификацию. Описанный выше подход с собственным OAuth — рекомендуемый.
-   **Публичный Рееестр MCP:** Это отдельный сервис от создателей протокола. Для публикации вашего сервера в этот *глобальный список* требуется аутентификация через их методы (например, GitHub OAuth). Это не является требованием для работы вашего собственного приложения.

---

## 7. FAQ (Часто Задаваемые Вопросы)

### **Вопрос:** Нужно ли выносить MCP-сервер в отдельный микросервис?

**Ответ:** Нет, на текущем этапе **настоятельно рекомендуется интегрировать функциональность MCP-сервера непосредственно в существующий монолитный бэкенд.**

-   **Причина:** MCP-сервер по своей сути является лишь еще одним "адаптером" или API для доступа к уже существующей бизнес-логике и данным. 

-   **Преимущества интеграции в монолит:**
    -   **Простота:** Отсутствие необходимости в создании и поддержке нового сервиса, CI/CD и инфраструктуры.
    -   **Переиспользование кода:** Прямой доступ к сервисам и моделям данных без сетевых вызовов и дублирования кода.
    -   **Надежность:** Гарантия атомарности транзакций в рамках одного процесса.

-   **Недостатки отдельного микросервиса:**
    -   **Преждевременная оптимизация:** Решает проблемы (например, независимое масштабирование), которых у вас еще нет.
    -   **Значительное усложнение:** Требует создания внутреннего API, решает проблемы распределенных транзакций и увеличивает операционные издержки.

**Вывод:** Начинайте с интеграции в монолит. Выделение в микросервис можно рассматривать в далеком будущем, только если для этого появятся реальные предпосылки (например, аномальный рост трафика именно от MCP-агентов).
