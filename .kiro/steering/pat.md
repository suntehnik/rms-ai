# Гайд по созданию Personal Access Tokens (PAT) в Go

Реализация Personal Access Tokens (PAT) в Go — это больше следование правильному *шаблону безопасности*, чем использование одной конкретной библиотеки. Нет единой "drop-in" библиотеки для PAT, как, например, для JWT, потому что логика тесно связана с вашей моделью пользователей и прав доступа.

Однако, есть стандартные криптографические библиотеки Go, которые необходимо использовать для построения безопасной системы PAT.

### Принцип Безопасной Реализации PAT

Самое главное правило: **НИКОГДА не храните токен в открытом виде в базе данных.** К токену нужно относиться как к паролю. Хранить следует только его **хэш**.

---

### Шаг 1: Генерация Безопасного Токена

Токен должен быть длинной, криптографически случайной строкой с высокой энтропией. Хорошей практикой (как у GitHub) является добавление префикса для идентификации типа токена.

*   **Префикс:** Несекретная часть, например `mcp_pat_`.
*   **Секрет:** Случайная строка, например, из 32-64 байт, закодированная в Base64 или Hex.

Для генерации случайной части используется стандартный пакет **`crypto/rand`**.

```go
package main

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
)

// generateSecureToken создает безопасный токен.
// `numberOfBytes` - это количество случайных байт для секретной части.
// 32 байта (256 бит) - хороший и надежный выбор.
func generateSecureToken(prefix string, numberOfBytes int) (string, string, error) {
	// Генерируем случайные байты
	secretBytes := make([]byte, numberOfBytes)
	if _, err := rand.Read(secretBytes); err != nil {
		return "", "", fmt.Errorf("не удалось сгенерировать случайные байты: %w", err)
	}

	// Кодируем секретную часть в URL-safe Base64
	secretPart := base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(secretBytes)
	
	// Собираем полный токен
	fullToken := prefix + secretPart

	return fullToken, secretPart, nil
}

func main() {
	prefix := "mcp_pat_"
	fullToken, _, err := generateSecureToken(prefix, 32)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Сгенерированный токен: %s
", fullToken)
	fmt.Printf("Длина токена: %d
", len(fullToken))
}
```

### Шаг 2: Хранение Токена (Хэширование)

Для хэширования токенов (как и паролей) лучшей библиотекой в экосистеме Go является **`golang.org/x/crypto/bcrypt`**. Она автоматически генерирует "соль" и выполняет достаточно медленное хэширование, что защищает от атак перебором (brute-force).

```go
import "golang.org/x/crypto/bcrypt"

// Хэшируем секретную часть токена перед сохранением в БД
func hashToken(secretPart string) (string, error) {
    hashedBytes, err := bcrypt.GenerateFromPassword([]byte(secretPart), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashedBytes), nil
}

// Проверяем, что входящий токен совпадает с хэшем в БД
func compareTokenWithHash(secretPart, hash string) error {
    return bcrypt.CompareHashAndPassword([]byte(hash), []byte(secretPart))
}
```

**Структура таблицы в БД:**
*   `id` (Primary Key)
*   `user_id` (Foreign Key к пользователю)
*   `token_hash` (string, здесь хранится результат `bcrypt`)
*   `prefix` (string, например, `mcp_pat_`)
*   `name` / `description` (string, описание токена, которое дал пользователь)
*   `scopes` (jsonb/text, права доступа токена)
*   `created_at`, `expires_at`, `last_used_at` (timestamps)

### Шаг 3: Проверка Токена при Запросе

1.  Клиент присылает заголовок: `Authorization: Bearer mcp_pat_aBcDeFg...`
2.  На бэкенде вы извлекаете токен и разделяете его на префикс и секретную часть.
3.  Вы делаете запрос к БД, чтобы найти все хэши токенов, принадлежащие данному пользователю (или ищете по короткой, несекретной части токена, если она есть).
4.  В цикле сравниваете секретную часть пришедшего токена с каждым хэшем из БД с помощью `bcrypt.CompareHashAndPassword`.
5.  Если совпадение найдено — авторизация успешна.

### Рекомендуемые Библиотеки (Итог)

Для построения надежной системы PAT вам не нужна одна большая библиотека, а нужен правильный набор стандартных инструментов:

1.  **Генерация:** **`crypto/rand`** — для создания криптографически случайных данных.
2.  **Кодирование:** **`encoding/base64`** или **`encoding/hex`** — для представления случайных байтов в виде строки.
3.  **Хэширование:** **`golang.org/x/crypto/bcrypt`** — для безопасного хэширования и сравнения токенов. Это самая важная часть.
4.  **Работа с БД:** Любая стандартная библиотека, которую вы уже используете (`database/sql`, `gorm`, `sqlx` и т.д.).

### Сторонние Комплексные Решения

Если ваша система в будущем потребует не только PAT, но и полноценный OAuth2, OpenID Connect и т.д., стоит посмотреть в сторону **Ory**. Это набор зрелых Go-сервисов для управления идентификацией.

*   **Ory Kratos:** Управление пользователями (регистрация, вход, профили).
*   **Ory Hydra:** Полноценный OAuth 2.0 и OpenID Connect сервер.

Использование Ory — это более сложный, но и более комплексный подход. Для реализации одних только PAT он может быть избыточен, но полезен как пример лучших практик в коде на Go.
