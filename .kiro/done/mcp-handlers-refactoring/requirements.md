# Требования к рефакторингу обработчиков MCP

## 1. Введение и текущая проблема

В настоящее время основная логика обработки вызовов инструментов MCP (Model Context Protocol) сосредоточена в файле `internal/handlers/mcp_tools_handler.go` и структуре `ToolsHandler`. Эта структура стала слишком большой и сложной, она зависит от множества сервисов и обрабатывает все инструменты, связанные с различными доменными сущностями (Epics, User Stories, Requirements и т.д.).

Такой подход нарушает ключевые принципы проектирования:
- **Принцип единственной ответственности (SRP):** Структура `ToolsHandler` имеет слишком много зон ответственности.
- **Принцип разделения интерфейсов (ISP):** Структура зависит от большого количества сервисов, которые не всегда используются ее методами одновременно.

Это приводит к трудностям в поддержке, тестировании и расширении кода.

## 2. Цели рефакторинга

- Улучшить архитектуру и читаемость кода обработчиков MCP.
- Усилить разделение ответственности между компонентами.
- Снизить связанность кода и сделать зависимости явными и минимальными.
- Повысить тестируемость отдельных обработчиков.
- Упростить процесс добавления новых инструментов и доменных сущностей в будущем.

## 3. Функциональные требования

### FR1: Декомпозиция `ToolsHandler`
Необходимо разбить монолитную структуру `ToolsHandler` на несколько более мелких, сфокусированных структур-обработчиков для каждой доменной сущности.

**Примеры новых структур:**
- `MCPEpicHandler`
- `MCPUserStoryHandler`
- `MCPRequirementHandler`
- `MCPSearchHandler`
- `MCPSteeringDocumentHandler`
- `MCPPromptHandler`
- `MCPAcceptanceCriteriaHandler`

### FR2: Минимизация зависимостей
Каждая новая структура-обработчик должна получать в качестве зависимостей только те сервисы, которые ей непосредственно необходимы для работы. Например, `MCPEpicHandler` должен зависеть только от `service.EpicService`.

### FR3: Создание фасада
Существующая структура `ToolsHandler` должна быть преобразована в фасад (или композитный обработчик), который будет содержать экземпляры новых, более мелких обработчиков.

### FR4: Делегирование вызовов
Метод `HandleToolsCall` в `ToolsHandler` должен быть обновлен. Его единственной задачей станет определение имени вызываемого инструмента и делегирование вызова соответствующему методу вложенного обработчика (например, `h.epicHandler.Create(...)`).

### FR5: Перенос и организация кода
Логика из `handle...` методов должна быть перенесена в методы новых структур-обработчиков. Файловая структура также должна быть реорганизована: код для `MCPEpicHandler` должен находиться в `mcp_epic_handler.go`, для `MCPUserStoryHandler` — в `mcp_user_story_handler.go` и так далее.

### FR6: Общая логика
Общие вспомогательные функции (например, `getUserFromContext`) или логика форматирования ответов, если она используется несколькими обработчиками, должны быть вынесены в общий пакет утилит или базовую структуру, чтобы избежать дублирования кода.

## 4. Нефункциональные требования

### NFR1: Сохранение внешнего контракта
Рефакторинг не должен изменять внешний API. Все JSON-RPC вызовы инструментов (`tools/call`) должны работать так же, как и до рефакторинга, с теми же параметрами и форматом ответа.

### NFR2: Тестовое покрытие
Существующее тестовое покрытие для логики обработчиков должно быть сохранено или увеличено. Все новые и измененные компоненты должны быть покрыты юнит-тестами.

## 5. Вне рамок текущей задачи

Следующие улучшения рекомендуются, но **не входят** в рамки данного рефакторинга:
- Изменение механизма классификации ошибок (функции `isDatabaseError` и т.п.).
- Вынесение логики логирования из `MCPHandler` в отдельный middleware.
