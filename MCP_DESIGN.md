# Дизайн-документ реализации MCP сервера и клиента

## 1. Введение

Этот документ описывает дизайн и архитектуру для интеграции поддержки протокола `Model Context Protocol` (MCP) в существующую систему управления требованиями. Цель — предоставить программируемый интерфейс для взаимодействия с системой, в том числе для ИИ-агентов.

Интеграция будет состоять из двух основных компонентов:
1.  **MCP Сервер**: Встроен в существующий Go бэкенд, предоставляет единую точку входа `/mcp` для всех MCP-запросов.
2.  **MCP Клиент**: CLI-агент, который позволяет пользователям взаимодействовать с системой через MCP-запросы.

Дизайн следует принципам, изложенным в `docs/MCP_Integration_Strategy.md`, но с ключевым изменением в механизме аутентификации: вместо OAuth будет использоваться **аутентификация по персональным токенам доступа (Personal Access Tokens - PAT)**.

## 2. Аутентификация: Personal Access Tokens (PAT)

Аутентификация всех MCP запросов будет производиться с помощью PAT. Это упрощает взаимодействие для программных клиентов и ИИ-агентов, устраняя необходимость в сложном потоке OAuth 2.0.

### 2.1. Жизненный цикл токена

1.  **Генерация**: Пользователь генерирует PAT через веб-интерфейс приложения. В процессе генерации пользователь должен иметь возможность указать:
    *   **Название токена**: Для легкой идентификации (например, "My CLI Agent").
    *   **Срок действия**: (Опционально) Дата, после которой токен станет недействительным.
    *   **Права доступа (Scopes)**: (На будущее) Возможность ограничить действия, которые можно выполнять с помощью токена (например, `read-only`). На первом этапе можно реализовать с полным доступом.
2.  **Отображение**: Сгенерированный токен отображается пользователю **только один раз**. Пользователь должен скопировать и сохранить его в безопасном месте. Система будет хранить только хеш токена.
3.  **Использование**: Клиент (агент) передает токен в HTTP-заголовке `Authorization` при каждом запросе к MCP-серверу.
    ```
    Authorization: Bearer <your_personal_access_token>
    ```
4.  **Проверка**: MCP-сервер на бэкенде будет извлекать токен из заголовка, находить соответствующий хеш в базе данных, проверять его валидность (срок действия, статус) и сопоставлять с пользователем, который его создал. Все дальнейшие операции в рамках этого запроса будут выполняться от имени данного пользователя.
5.  **Отзыв**: Пользователь может в любой момент отозвать (удалить) токен через веб-интерфейс.

### 2.2. Необходимые доработки API

Для поддержки PAT необходимо добавить новую группу эндпоинтов в REST API (например, `/api/v1/pats`):

*   `GET /api/v1/pats`: Получить список всех активных токенов пользователя (без самих токенов, только метаданные: название, дата создания, срок действия).
*   `POST /api/v1/pats`: Создать новый токен.
*   `DELETE /api/v1/pats/{id}`: Отозвать (удалить) токен.

## 3. Дизайн MCP Сервера

MCP-сервер будет реализован как часть существующего Go-монолита, как рекомендовано в `MCP_Integration_Strategy.md`.

### 3.1. Точка входа (Endpoint)

Будет создан один новый HTTP POST эндпоинт: `/mcp`.

*   **Метод**: `POST`
*   **Путь**: `/mcp`
*   **Content-Type**: `application/json`

Этот эндпоинт будет принимать все MCP-запросы в формате JSON-RPC 2.0.

### 3.2. Обработка запросов и ответов

1.  **Парсинг**: Обработчик `/mcp` будет парсить входящий JSON-запрос, который должен соответствовать спецификации MCP.
    ```json
    {
      "mcp.version": "2025-06-18",
      "mcp.function": "mcp.create",
      "mcp.context": {
        "resource": {
          "type": "epic",
          "spec": {
            "title": "Новый Эпик",
            "priority": 1
          }
        }
      },
      "mcp.auth": {
        "token": "<personal_access_token>"
      }
    }
    ```
2.  **Аутентификация**: Извлекается `mcp.auth.token`, валидируется, и определяется пользователь. Если токен невалиден, возвращается стандартная ошибка MCP.
3.  **Диспетчеризация**: На основе поля `mcp.function` (например, `mcp.create`, `mcp.get`, `mcp.list`) запрос передается соответствующему внутреннему обработчику.
4.  **Маппинг и выполнение**: Внутренний обработчик преобразует параметры из `mcp.context` в вызовы существующих сервисов и репозиториев (тех же, что используются REST API).
5.  **Формирование ответа**: Результат выполнения (или ошибка) форматируется в соответствии со спецификацией MCP и отправляется клиенту.

### 3.3. Маппинг MCP функций на API

Ниже представлен маппинг основных MCP-функций на существующие эндпоинты, описанные в `swagger.yaml`.

| MCP Функция | MCP Ресурс (`type`) | REST Эндпоинт (пример) | Описание |
| :--- | :--- | :--- | :--- |
| `mcp.create` | `epic` | `POST /api/v1/epics` | Создает новый эпик. Поля из `mcp.context.resource.spec` мапятся на тело запроса `CreateEpicRequest`. |
| `mcp.create` | `user_story` | `POST /api/v1/user-stories` | Создает новую пользовательскую историю. |
| `mcp.create` | `requirement` | `POST /api/v1/requirements` | Создает новое требование. |
| `mcp.get` | `epic` | `GET /api/v1/epics/{id}` | Получает эпик по `id` или `reference_id`. |
| `mcp.get` | `user_story` | `GET /api/v1/user-stories/{id}` | Получает пользовательскую историю. |
| `mcp.list` | `epic` | `GET /api/v1/epics` | Получает список эпиков. Фильтры из `mcp.context.resource.spec` мапятся на query-параметры. |
| `mcp.list` | `requirement` | `GET /api/v1/requirements` | Получает список требований с фильтрацией. |
| `mcp.update` | `epic` | `PUT /api/v1/epics/{id}` | Обновляет эпик. |
| `mcp.delete` | `epic` | `DELETE /api/v1/epics/{id}` | Удаляет эпик. |
| `mcp.search` | `any` | `GET /api/v1/search` | Выполняет глобальный поиск. Параметры поиска передаются в `mcp.context.resource.spec`. |

**Пример: Создание Эпика**

**MCP Запрос:**
```json
{
  "mcp.version": "2025-06-18",
  "mcp.function": "mcp.create",
  "mcp.context": {
    "resource": {
      "type": "epic",
      "spec": {
        "title": "Поддержка MCP в CLI",
        "priority": 1,
        "description": "Реализовать сервер и клиент MCP для взаимодействия с системой."
      }
    }
  },
  "mcp.auth": { "token": "..." }
}
```

**Действия сервера:**
1.  Валидировать токен.
2.  Вызвать внутренний сервис, эквивалентный `POST /api/v1/epics`.
3.  Тело запроса к сервису будет сформировано из `mcp.context.resource.spec`:
    ```go
    req := CreateEpicRequest{
        Title:       "Поддержка MCP в CLI",
        Priority:    1,
        Description: "Реализовать сервер и клиент MCP для взаимодействия с системой.",
        CreatorID:   // ID пользователя, ассоциированного с токеном
    }
    ```
4.  Вернуть созданный эпик в MCP-формате.

### 3.4. Обработка ИИ-функций

Функции, отмеченные в `jtbd-mcp-mapping.md` как требующие ИИ-логики (например, `ИИ-анализ качества`, `ИИ-предложение связей`), будут обрабатываться по особому сценарию.

1.  MCP-сервер получает запрос на такую функцию (например, `mcp.ai.analyze_quality`).
2.  Сервер собирает необходимый контекст из базы данных, используя существующие сервисы (например, загружает текст требования и связанные с ним комментарии).
3.  Собранные данные форматируются в виде промпта для большой языковой модели (LLM).
4.  Сервер делает вызов к LLM.
5.  Ответ от LLM парсится и форматируется в виде стандартного MCP-ответа.

Для этого потребуется ввести новые `mcp.function` с префиксом `mcp.ai.*`.

## 4. Дизайн MCP Клиента (Агента)

Клиент будет представлять собой CLI-приложение.

### 4.1. Конфигурация и аутентификация

1.  **Первый запуск**: При первом запуске или по команде `login` клиент запрашивает у пользователя:
    *   **URL сервера**: Адрес хоста, где развернуто приложение (например, `https://my-req-system.com`).
    *   **Personal Access Token**: Сгенерированный в веб-интерфейсе токен.
2.  **Хранение**:
    *   URL сервера сохраняется в простом конфигурационном файле (например, `~/.config/mcp-agent/config.json`).
    *   Токен **должен** храниться в безопасном системном хранилище ОС (macOS Keychain, Windows Credential Manager, Linux Secret Service).

### 4.2. Структура команд

Команды клиента будут интуитивно мапиться на MCP-функции.

*   `mcp-agent create epic --title "Новый эпик" --priority 1` -> `mcp.create`
*   `mcp-agent get epic EP-123` -> `mcp.get`
*   `mcp-agent list requirements --status "active"` -> `mcp.list`
*   `mcp-agent search "аутентификация"` -> `mcp.search`

### 4.3. Взаимодействие с сервером

1.  Клиент конструирует JSON-RPC 2.0 тело запроса на основе введенной команды и флагов.
2.  Извлекает токен из системного хранилища.
3.  Отправляет `POST` запрос на `{server_url}/mcp`.
4.  Парсит ответ и выводит результат пользователю в читаемом виде или сообщает об ошибке.

## 5. Маппинг моделей данных

MCP-ресурсы будут напрямую соответствовать моделям данных из `swagger.yaml`.

| MCP Ресурс (`type`) | Модель в `swagger.yaml` | Ключевые поля |
| :--- | :--- | :--- |
| `epic` | `product-requirements-management_internal_models.Epic` | `id`, `reference_id`, `title`, `description`, `status`, `priority` |
| `user_story` | `product-requirements-management_internal_models.UserStory` | `id`, `reference_id`, `title`, `description`, `status`, `priority`, `epic_id` |
| `requirement` | `product-requirements-management_internal_models.Requirement` | `id`, `reference_id`, `title`, `description`, `status`, `priority`, `user_story_id` |
| `comment` | `product-requirements-management_internal_models.Comment` | `id`, `content`, `author_id`, `entity_id`, `entity_type` |

## 6. Обработка ошибок

Ошибки будут возвращаться в стандартном формате JSON-RPC 2.0, как определено в спецификации MCP.

**Пример ошибки (токен недействителен):**
```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32001,
    "message": "Authentication failed: Invalid or expired token",
    "data": {
      "type": "auth_error"
    }
  },
  "id": "request-id-123"
}
```

Сервер будет мапить внутренние ошибки (например, "сущность не найдена", "неверный переход статуса") на соответствующие коды ошибок MCP.
